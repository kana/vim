*undo.txt*      For Vim バージョン 7.2.  Last change: 2009 Apr 12


		  VIM REFERENCE MANUAL    by Bram Moolenaar


undo と redo						*undo-redo*

基本的なことは |02.5| で説明されています。

1. undo と redo のコマンド	|undo-commands|
2. Undo の二つの方式		|undo-two-ways|
3. Undo ブロック		|undo-blocks|
4. Undo ブランチ		|undo-branches|
5. 備考				|undo-remarks|

==============================================================================
1. undo と redo のコマンド				*undo-commands*

<Undo>		or					*undo* *<Undo>* *u*
u			[count] 個の変更を元に戻す。 {Vi は 1 レベルだけ}

							*:u* *:un* *:undo*
:u[ndo] 		一つの変更を元に戻す。 {Vi は 1 レベルだけ}

:u[ndo] {N}		変更番号 {N} の直後にジャンプする。{N} の意味について
			は |undo-branches| を参照。 {Vi にはない}

							*CTRL-R*
CTRL-R			undo された変更を [count] 個やり直す (redoする)。
			{Vi ではこのキーはスクリーンの再描画}

							*:red* *:redo* *redo*
:red[o]			undo された変更を一つやり直す。 {Vi: redo はない}

							*U*
U			最近実行された、一つの行の中でのすべての変更を元に戻
			す。 {Vi では行から移動すると使えない}

変更は記録されます。上記の undo コマンドや redo コマンドを使うと、それぞれの変
更が加えられる前のテキストに戻したり、変更を元に戻した後でその変更を再び加える
ことができます。

"U" コマンドは他のコマンドと同様に undo/redo の対象となります。つまり、"u" コ
マンドで "U" コマンドを undo したり、'CTRL-R' コマンドでそれを redo したりでき
ます。"U" と "u" と 'CTRL-R' を混ぜて使うと、"U" コマンドが直前の "U" コマンド
以前の状態を復元することに気付くでしょう。この動作はわかりにくいかもしれません
が、練習して慣れてください。
"U" コマンドはバッファを変更有りの状態にします。つまり、"U" コマンドで変更が加
えられる前のテキストに戻しても、それは変更有りの状態として認識されます。"u" を
使って変更無しの状態まで undo してください。

==============================================================================
2. undo の二つの方式					*undo-two-ways*

undo コマンドと redo コマンドの動作は 'cpoptions' の 'u' フラグに依存していま
す。Vim 方式 ('u'がない場合) と Vi 互換方式 ('u'がある場合) があります。Vim 方
式では "uu" は二つの変更を undo します。Vi 互換方式では "uu" は何もしません
(undo を undo する)。

'u' がない場合。Vim 方式:
undo コマンドで過去に戻れます。そして、redo コマンドで再び先に進むことができま
す。undo コマンドを実行した後で新しい変更を加えると、redo はできなくなります。

'u' がある場合。Vi 互換方式:
undo コマンドは直前の変更と undo コマンドを undo します。redo コマンドは直前の
undo コマンドを繰り返します。変更コマンドが繰り返されるわけではないので、そう
したい場合は "." を使ってください。

例		Vim 方式		Vi 互換方式 ~
"uu"		2回 undo		変更なし
"u CTRL-R"	変更なし		2回 undo

理由:	    Nvi では CTRL-R の代わりに "." コマンドを使います。あいにくこれは
	    Vi 互換ではありません。例えば、"dwdwu." は Vi では二つの単語が削除
	    されますが、Nvi ではなにも変更されません。

==============================================================================
3. Undo ブロック					*undo-blocks*

undo コマンドは普通は一つのコマンドを undo します。そのコマンドがいくつの変更
を加えるかは関係ありません。この undo 可能な変更の組が undo ブロックです。例え
ば、キーの入力によって関数が呼ばれた場合、その関数内のすべてのコマンドは一緒に
undo されます。

関数やスクリプトを作るとき、undo 可能な変更を新しく追加するのではなく、その変
更を直前の変更につなげたい場合は、次のコマンドを使ってください:

						*:undoj* *:undojoin* *E790*
:undoj[oin]		以降の変更を直前の undo ブロックにつなげる。
			警告: 注意して使ってください。ユーザーが適切に変更を
			undo するのを妨げてしまうかもしれません。undo や redo
			の後でこのコマンドを使わないでください。
			{Vi にはない}

これは特に変更の途中でプロンプトを表示するような場合に便利です。例えば関数の中
で |getchar()| を呼び出すなど。変更をつなげてしかるべき関連性のある変更がそこ
にあることがわかっている場合に使ってください。

このコマンドは単独では機能しません。なぜなら、次のキー入力によって再び新しい変
更が開始されるからです。しかし例えば次のように使うことはできます: >

	:undojoin | delete

この後で "u" コマンドを実行すると delete コマンドとその直前の変更が undo され
ます。

反対の動作、つまり変更を二つの undo ブロックに分けるには、インサートモードで
CTRL-G u を使います。インサートコマンドを部分ごと (例えば文単位) に undo でき
るようにしたい場合に便利です。 |i_CTRL-G_u|

==============================================================================
4. Undo ブランチ				*undo-branches* *undo-tree*

ここまでは一線上の undo/redo について説明してきました。しかし、それを枝分かれ
させることもできます。枝分かれは、変更を undo してから新しい変更を加えることで
起こります。undo された変更は枝 (ブランチ) になります。以下のコマンドで枝に移
動できます。

ユーザーマニュアルに説明があります: |usr_32.txt|.

							*:undol* *:undolist*
:undol[ist]		変更木 (tree) の、葉 (leaf) を一覧表示する。例:
				番号   変更      時刻 ~
				4      10	 10:34:11
				18     4	 11:01:46

			"番号" 列は変更番号です。この番号は連続的に増えてい
			き、undo 可能な変更の識別番号として使えます。 |:undo|
			参照。
			"変更" 列は木のルートから葉までの変更の数です。
			"時刻" 列は変更が加えられた時刻です。

							*g-*
g-			古いテキスト状態に移動する。カウント指定で繰り返し回数
			を指定できます。 {Vi にはない}
							*:ea* *:earlier*
:earlier {count}	{count} 回前の古いテキスト状態に移動する。
:earlier {N}s		{N} 秒前の古いテキスト状態に移動する。
:earlier {N}m		{N} 分前の古いテキスト状態に移動する。
:earlier {N}h		{N} 時間前の古いテキスト状態に移動する。

							*g+*
g+			新しいテキスト状態に移動する。カウント指定で繰り返し回
			数を指定できます。 {Vi にはない}
							*:lat* *:later*
:later {count}		{count} 回後の新しいテキスト状態に移動する。
:later {N}s		{N} 秒後の新しいテキスト状態に移動する。
:later {N}m		{N} 分後の新しいテキスト状態に移動する。
:later {N}h		{N} 時間後の新しいテキスト状態に移動する。


Note: テキスト状態は、'undolevels' により undo 情報がクリアされると、到達不可
能になります。

時間を移動すると一度に複数の変更が現れることもあります。これは undo ツリーを移
動して新しい変更を加えたときに起こります。

例

次のテキストがあります:
	one two three ~

"x" を 3 回押して最初の単語を削除します:
	ne two three ~
	e two three ~
	 two three ~

"u" を 3 回押してそれを undo します:
	e two three ~
	ne two three ~
	one two three ~

"x" を 3 回押して二番目の単語を削除します:
	one wo three ~
	one o three ~
	one  three ~

"g-" を 3 回押してそれを undo します:
	one o three ~
	one wo three ~
	 two three ~

最初の undo ブランチ ("one" を削除した後) に戻りました。さらに "g-" を押してい
くと元のテキストに戻ります:
	e two three ~
	ne two three ~
	one two three ~

":later 1h" を実行すると最後の変更にジャンプします:
	one  three ~

":earlier 1h" を実行すると最初に戻ります:
	one two three ~


Note: "u" と CTRL-R では "g-" と "g+" のようにすべてのテキスト状態に移動するこ
とはできません。

==============================================================================
5. 備考							*undo-remarks*

記録される変更の数は 'undolevels' オプションで設定できます。ゼロに設定すると、
Vi 互換方式の動作になります。マイナスの値に設定すると undo は使用できなくなり
ます。メモリが足りない場合に設定してください。

バッファのマーク ('a から 'z) はテキストと同様に記録、復元されます。
{Vi とは少し動作が違います}

すべての変更を undo したとき、バッファは変更ありとはみなされません。その状態か
らは ":q" (":q!"ではなく) で Vim を終了できます {Vi にはない}。Note: これはい
つファイルを保存したかに関係します。":w" の後で "u" を実行すると、保存したとき
から見てバッファは変更された状態なので、バッファは変更ありと認識されます。

マニュアル設定の折り畳み (|folding|) を使っているとき、折り畳みは記録も復元も
されません。変更が折り畳みの中だけで行われた場合のみ (折り畳みの最初と最後の行
が変わらないので) 折り畳みは維持されます。

番号レジスタを使って削除を元に戻すこともできます。テキストを削除すると、それは
"1 レジスタに記録されます。元々 "1 にあったものは "2 にシフトされ、他の番号レ
ジスタも同様にシフトされます。"9 レジスタの内容は失われます。そして、プットコ
マンド '"1P' を使って削除されたテキストを元に戻すことができます。(削除やコピー
の操作をした後ならテキストは無名レジスタに入っているので 'P' や 'p' でも元に戻
せます)。三回前に削除されたテキストなら '"3P' で戻せます。

						*redo-register*
数回に分けて削除されたテキストを戻したい場合は、"." コマンドの特殊な機能が役に
立ちます。"." コマンドは使用されたレジスタの番号を増加させます。例えば、""1P"
を実行した後で "." を押すと '"2P' が実行されます。さらに "." を押していくとす
べての番号レジスタが挿入されます。

例:		'dd....' でテキストを削除したら '"1P....' で元に戻せる。

削除されたテキストがどのレジスタに記録されているかわからないときは :display コ
マンドで確認できます。あるいは、'"1P' を実行してみて、もしそれが違うものなら
'u.' を実行します。'u.' は最初にプットされたテキストを削除し、二番目のレジスタ
を使ってプットコマンドを実行します。目的のものが出るまで 'u.' を繰り返してくだ
さい。

 vim:tw=78:ts=8:ft=help:norl:
